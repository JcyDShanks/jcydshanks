<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Eventbus原理 | JcyDs' Blog</title><meta name="description" content="Eventbus原理greenrobot&#x2F;EventBus是一个灵活的消息传递方案，能够在不同的类或组件中传递消息，使用起来简单方便，它使用发布订阅模式支持组件之间的通信，不需要显式地注册回调，比观察者模式更灵活，可用于替换Java中传统的事件监听模式，EventBus的作用就是解耦，它不是通用的发布订阅系统，也不能用于进程间通信。我们看一下 EventBus 基本用法： 123456789101"><meta name="keywords" content="Android, iOS, Flutter"><meta name="author" content="Chunyu"><meta name="copyright" content="Chunyu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/headimg.jpg"><link rel="canonical" href="http://yoursite.com/2020/07/26/Eventbus%E5%8E%9F%E7%90%86/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Eventbus原理"><meta property="og:url" content="http://yoursite.com/2020/07/26/Eventbus%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="JcyDs' Blog"><meta property="og:description" content="Eventbus原理greenrobot&#x2F;EventBus是一个灵活的消息传递方案，能够在不同的类或组件中传递消息，使用起来简单方便，它使用发布订阅模式支持组件之间的通信，不需要显式地注册回调，比观察者模式更灵活，可用于替换Java中传统的事件监听模式，EventBus的作用就是解耦，它不是通用的发布订阅系统，也不能用于进程间通信。我们看一下 EventBus 基本用法： 123456789101"><meta property="og:image" content="http://yoursite.com/img/cover/10.jpg"><meta property="article:published_time" content="2020-07-26T09:11:53.767Z"><meta property="article:modified_time" content="2020-07-26T09:11:53.768Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="Android IPC机制" href="http://yoursite.com/2020/07/19/Android%20IPC%E6%9C%BA%E5%88%B6/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: {"languages":{"author":"作者: Chunyu","link":"链接: ","source":"来源: JcyDs' Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/headimg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">1</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Eventbus原理"><span class="toc-number">1.</span> <span class="toc-text">Eventbus原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#register流程"><span class="toc-number">1.1.</span> <span class="toc-text">register流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subscribe-Annotation"><span class="toc-number">1.2.</span> <span class="toc-text">Subscribe Annotation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引用"><span class="toc-number">1.2.1.</span> <span class="toc-text">引用</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover/10.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">JcyDs' Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Eventbus原理</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-26 17:11:53"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-26 17:11:53"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-26</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Eventbus原理"><a href="#Eventbus原理" class="headerlink" title="Eventbus原理"></a>Eventbus原理</h1><p>greenrobot/EventBus是一个灵活的消息传递方案，能够在不同的类或组件中传递消息，使用起来简单方便，它使用发布订阅模式支持组件之间的通信，不需要显式地注册回调，比观察者模式更灵活，可用于替换Java中传统的事件监听模式，EventBus的作用就是解耦，它不是通用的发布订阅系统，也不能用于进程间通信。<br>我们看一下 EventBus 基本用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册EventBus，接受事件</span><br><span class="line">class Fragment &#123;</span><br><span class="line">    public void onCreate()&#123;</span><br><span class="line">       EventBus.getDefault().register(this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void onDestroy()&#123;</span><br><span class="line">       EventBus.getDefault().unregister(this);</span><br><span class="line">    &#125;</span><br><span class="line">    @Subscribe</span><br><span class="line">    public void onReceive(SomeEvent event) &#123;</span><br><span class="line">        &#x2F;&#x2F; handle your event here...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理任务，发送事件</span><br><span class="line">public class Service &#123;</span><br><span class="line">    public void doSomeThing()&#123;</span><br><span class="line">        &#x2F;&#x2F; do your work</span><br><span class="line">        &#x2F;&#x2F; send event</span><br><span class="line">        EventBus.getDefault().post(new SomeEvent1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="register流程"><a href="#register流程" class="headerlink" title="register流程"></a>register流程</h2><p>从使用来看，Eventbus的第一步要调用<code>getDefault()</code>来获取一个单例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Convenience singleton for apps using a process-wide EventBus instance. *&#x2F;</span><br><span class="line">static volatile EventBus defaultInstance;</span><br><span class="line"></span><br><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">    EventBus instance &#x3D; defaultInstance;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            instance &#x3D; EventBus.defaultInstance;</span><br><span class="line">            if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                instance &#x3D; EventBus.defaultInstance &#x3D; new EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个标准的单例写法，defaultInstance用了<code>volatile</code>关键字，防止指令重排和保持内存可见。</p>
<ul>
<li>内存可见性：所有线程都能看到共享内存的最新状态，保证跨线程的时候的值的同步，避免出现脏数据的现象。</li>
<li>防止指令重排：提高程序效率，保证代码执行的有序性。<br>然后通过双重校验+同步锁的方式实现单例。</li>
</ul>
<p>获取到了单例对象后，要进行register操作，绑定监听，register源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final SubscriberMethodFinder subscriberMethodFinder;</span><br><span class="line"></span><br><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">    Class&lt;?&gt; subscriberClass &#x3D; subscriber.getClass();</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册流程基本大致流程就是：</p>
<ol>
<li>根据对象获取到类</li>
<li>通过<code>subscriberMethodFinder</code>查找该类所有的订阅的方法</li>
<li>同步的方式将订阅者与订阅者的类订阅的方法进行关联</li>
</ol>
<p>通过register可以看出，Eventbus内部通过<code>subscriberClass</code>来获取到绑定的class，<br>然后在通过<code>subscriberMethodFinder.findSubscriberMethods(subscriberClass);</code>来查找class订阅的方法列表，其中<code>SubscriberMethod</code>是由EventBus内部使用并生成订阅者索引。<br>最后通过循环订阅当前实例订阅方法索引。</p>
<p>subscriberMethodFinder的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubscriberMethodFinder(List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes, boolean strictMethodVerification,</span><br><span class="line">                       boolean ignoreGeneratedIndex) &#123;</span><br><span class="line">    this.subscriberInfoIndexes &#x3D; subscriberInfoIndexes;</span><br><span class="line">    this.strictMethodVerification &#x3D; strictMethodVerification;</span><br><span class="line">    this.ignoreGeneratedIndex &#x3D; ignoreGeneratedIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>猜测构造器的参数的字面意思：</p>
<ul>
<li><strong>subscriberInfoIndexes</strong>：订阅索引，一般由EventBus的注释预处理器生成的索引</li>
<li><strong>strictMethodVerification</strong>： 启用严格的方法验证（默认值：false）</li>
<li><strong>ignoreGeneratedIndex</strong>：即使存在生成的索引也强制使用反射（默认值：false）<br>构造了对象之后，findSubscriberMethods(subscriberClass)方法实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static final Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    &#x2F;&#x2F; METHOD_CACHE中查找列表</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    if (subscriberMethods !&#x3D; null) &#123;</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ignoreGeneratedIndex) &#123;</span><br><span class="line">        subscriberMethods &#x3D; findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        subscriberMethods &#x3D; findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
findSubscriberMethods方法中，首先尝试在<code>METHOD_CACHE</code>中根据class来查找方法列表，如果不为空，直接return。<br>如果是空的，根据<code>ignoreGeneratedIndex</code>是否强制反射在<code>findUsingInfo</code>或<code>findUsingReflection</code>方法中获取订阅方法列表，如果还是空的，就抛出异常。<br>否则，就把获取到了列表添加到缓存中并return。</li>
</ul>
<p>Evenbus根据ignoreGeneratedIndex，实现的两种获取订阅方法列表方法的方案：</p>
<ul>
<li>使用反射查找索引</li>
<li>使用类的信息生成索引</li>
</ul>
<p>这里分析一下不使用反射获取订阅方法索引的方法findUsingInfo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    &#x2F;&#x2F;同步查找，找到FIND_STATE_POOL中第一个FindState后return</span><br><span class="line">    FindState findState &#x3D; prepareFindState();</span><br><span class="line">    &#x2F;&#x2F; 这个时候给findState.clazz赋值subscriberClass</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历findState.clazz !&#x3D; null</span><br><span class="line">    while (findState.clazz !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过findState 查找订阅信息</span><br><span class="line">        findState.subscriberInfo &#x3D; getSubscriberInfo(findState);</span><br><span class="line">        if (findState.subscriberInfo !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 订阅信息不为空，获取到监听者方法数组</span><br><span class="line">            SubscriberMethod[] array &#x3D; findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            &#x2F;&#x2F; 对数组进行遍历，进行添加校验，如果通过则可以添加到监听方法中</span><br><span class="line">            for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据subscriberClass来查找订阅信息，如果能够查找到，就能通过订阅信息获取到订阅方法列表并进行检查后添加到findState的subscriberMethods中，如果查不到就走到了findUsingReflectionInSingleClass方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 这比getMethods快，尤其是当订阅者是pat类（如活动）时</span><br><span class="line">            methods &#x3D; findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; catch (Throwable th) &#123;</span><br><span class="line">            methods &#x3D; findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            int modifiers &#x3D; method.getModifiers();</span><br><span class="line">            if ((modifiers &amp; Modifier.PUBLIC) !&#x3D; 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">                &#x2F;&#x2F; 检查方法参数数量 &#x3D;&#x3D; 1</span><br><span class="line">                if (parameterTypes.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 查找Subscribe注解</span><br><span class="line">                    Subscribe subscribeAnnotation &#x3D; method.getAnnotation(Subscribe.class);</span><br><span class="line">                    if (subscribeAnnotation !&#x3D; null) &#123;</span><br><span class="line">                        Class&lt;?&gt; eventType &#x3D; parameterTypes[0];</span><br><span class="line">                        if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                            ThreadMode threadMode &#x3D; subscribeAnnotation.threadMode();</span><br><span class="line">                            &#x2F;&#x2F; 添加到findState.subscriberMethods</span><br><span class="line">                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                ...</span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中使用了反射，首先使用getDeclaredMethods来提升反射效率，如果不行再走正常的反射方式，获取到methods后，循环查找只有一个参数、添加了Subscribe类注解的方法，查到方法后添加到findState.subscriberMethods中，如果查不到就抛出异常。</p>
<p>最后循环注册索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line">&#x2F;&#x2F; subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        Class&lt;?&gt; eventType &#x3D; subscriberMethod.eventType;</span><br><span class="line">        &#x2F;&#x2F; 新的订阅</span><br><span class="line">        Subscription newSubscription &#x3D; new Subscription(subscriber, subscriberMethod);</span><br><span class="line">        &#x2F;&#x2F; 订阅数组</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);</span><br><span class="line">        if (subscriptions &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 为空，重新初始化并放入最新的订阅</span><br><span class="line">            subscriptions &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 检查是否已经订阅过</span><br><span class="line">            if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 订阅数量</span><br><span class="line">        int size &#x3D; subscriptions.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; size; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 检查订阅优先级</span><br><span class="line">            if (i &#x3D;&#x3D; size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 订阅的类型</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents &#x3D; typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedEvents &#x3D;&#x3D; null) &#123;</span><br><span class="line">            subscribedEvents &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        &#x2F;&#x2F; 粘性事件处理</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先，通过subscriberMethod来获取到注册类，然后生产一个新的订阅newSubscription，通过subscriptionsByEventType获取到已订阅的列表，如果没有任何订阅直接添加新的订阅。如果已有订阅需要进行一个重复校验。<br>根据订阅的优先级，在订阅列表中插入新的订阅。<br>最后把订阅者的类型取出，如果当前对象没有关联类型，则重新创建并添加关联，最后将时间类型添加到订阅事件列表中。</p>
<p>根据上面的代码分析，不难发现，实际上在Eventbus中，有几个关键的存储注册对象的属性和缓存机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line">private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">SubscriberMethodFinder</span><br><span class="line">private static final Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache &#x3D; new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>subscriptionsByEventType</strong></li>
</ul>
<p>用来关联订阅的类和订阅的方法</p>
<ul>
<li><strong>typesBySubscriber</strong></li>
</ul>
<p>用来关联对象和类</p>
<ul>
<li><strong>SubscriberMethodFinder</strong></li>
</ul>
<p>用来查找订阅方法的类<br>内部有</p>
<ul>
<li>Map&lt;Class&lt;?&gt;, List<SubscriberMethod>&gt; METHOD_CACHE = new ConcurrentHashMap&lt;&gt;();<br>有关联类与订阅的方法缓存ConcurrentHashMap</SubscriberMethod></li>
<li>List<SubscriberInfoIndex> subscriberInfoIndexes;<br>用来保存索引的subscriberInfoIndexes</SubscriberInfoIndex></li>
<li>FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];<br>findstate缓存池，实际上是个size = 4的数组</li>
</ul>
<p>以上就是register的基本流程。</p>
<h2 id="Subscribe-Annotation"><a href="#Subscribe-Annotation" class="headerlink" title="Subscribe Annotation"></a>Subscribe Annotation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">public @interface Subscribe &#123;</span><br><span class="line">    ThreadMode threadMode() default ThreadMode.POSTING;</span><br><span class="line"></span><br><span class="line">    boolean sticky() default false;</span><br><span class="line"></span><br><span class="line">    int priority() default 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><em>引用</em></h3><p>Retention为RUNTIME，虚拟机通过读取注解来实现一些功能</p>
<p>定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。来源于java.lang.annotation.RetentionPolicy的枚举类型值：<br>（1）.SOURCE:在源文件中有效（即源文件保留）编译成class文件将舍弃该注解。<br>（2）.CLASS:在class文件中有效（即class保留） 编译成dex文件将舍弃该注解。<br>（3）.RUNTIME:在运行时有效（即运行时保留） 运行时可见。<br>也就是说注解处理器能处理这三类的注解,我们通过反射的话只能处理RUNTIME类型的注解.</p>
<p>官方解释：指示注释类型的注释要保留多久。如果注释类型声明中不存在 Retention 注释，则保留策略默认为 RetentionPolicy.CLASS。只有元注释类型直接用于注释时，Target 元注释才有效。如果元注释类型用作另一种注释类型的成员，则无效。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chunyu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/26/Eventbus%E5%8E%9F%E7%90%86/">http://yoursite.com/2020/07/26/Eventbus%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">JcyDs' Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/cover/2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/19/Android%20IPC%E6%9C%BA%E5%88%B6/"><img class="next-cover" data-src="/img/cover/2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android IPC机制</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Chunyu</div><div class="framework-info"></div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>吉ICP备17007589号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">简</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>